package com.gxy.multithreading;

/**
 * 锁和条件是 Java 5中的新内容。
 * 在java5之前线程通信是使用对象的内置监视器编程实现的。
 * 锁和条件与内置监视器相比是非常强大切灵活的。
 *
 * 监视器是一个相互排斥且具备同步能力的对象。监视器中的一个时间点上，只能有一个线程执行一个方法。
 * 线程通过获取监视器上的锁进入监视器，并且通过释放锁退出监视器。
 * 任意对象都可能是一个监视器。
 * 一旦一个线程锁住对象，该对象就成为监视器。
 * 加锁是通过在方法或块上使用synchronized关键字来实现的，线程可能在监视器中等待。
 * 可以对监视器对象调用对象的wait()方法来释放锁，这样其他的一些监视器中的线程就可以获取它，也就有可能改变监视器的状态。
 * 当条件合适时，领一线程可以调用notify()或notifyAll()方法来通知一个或所有的等待线程重新获取锁并且恢复执行。
 *
 * wait()、notify和notifyAll()方法必须在这些方法的接收对象的同步方法或同步块中调用。
 * 否则就会出现IllegalMonitorStateException异常
 *
 * Created by gxy on 2016/3/8.
 */
public class Jave内置监视器 {
}
